<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Shader</title>
        <link rel="icon" href="./favicon.ico" type="image/x-icon" />

        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000;
            }
        </style>
    </head>
    <body>
        <script defer type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
                }
            }
        </script>

        <script type="x-shader/x-vertex" id="vertexShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;

            void main() {
                vNormal = normal;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>

        <script type="x-shader/x-fragment" id="fragmentShader">
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            uniform vec2 uResolution;

             float PI = 3.1415926535897932384626433832795;

            float sdCircle( vec2 p, float r ) {
                return length(p) - r;
            }

            // Calculate factorial assuming non-negative values
            float factorial(float n) {
                float result = 1.0;
                for (float i = 1.0; i <= n; i++) {
                    result *= float(i);
                }
                return result;
            }

            // Compute Associated Legendre Polynomial using an iterative method
            float P(float l, float m, float x) {
                // Create arrays to hold values
                float pmm = 1.0;
                if (m > 0.0) {
                    float somx2 = sqrt((1.0 - x) * (1.0 + x));
                    float fact = 1.0;
                    for (float i = 1.0; i <= m; i++) {
                        pmm *= -fact * somx2;
                        fact += 2.0;
                    }
                }
                if (l == m) return pmm;

                float pmmp1 = x * (2.0 * m + 1.0) * pmm;
                if (l == m + 1.0) return pmmp1;

                float pll = 0.0;
                for (float ll = m + 2.0; ll <= l; ++ll) {
                    pll = ((2.0 * ll - 1.0) * x * pmmp1 - (ll + m - 1.0) * pmm) / (ll - m);
                    pmm = pmmp1;
                    pmmp1 = pll;
                }
                return pll;
            }

            // Real part of spherical harmonic function
            float sphericalHarmonic(float l, float m, float theta, float phi) {
                float plm = P(l, abs(m), cos(theta));
                float normalization = sqrt((2.0 * float(l) + 1.0) / (4.0 * PI) * factorial(l - abs(m)) / factorial(l + abs(m)));
                return normalization * plm * cos(float(m) * phi);
            }


            void main() {
              //vec2 p = (2.0 * gl_FragCoord.xy - uResolution) / min(uResolution.x, uResolution.y);
              //float circle = sdCircle(p, 0.8) * 1.5;


              // draw circle border
              //float b = smoothstep(0.0, 0.01, abs(circle));
              //vec3 color = mix(vec3(1.0, 1.0, 1.0), vec3(.0, .0, .0), b);

              // Spheric harmonics of the third degree
              //if(circle < 0.0) {
              vec3 color = vec3(0.0);
              vec3 n = normalize(vNormal);
              float theta = acos(n.z);
              float phi = atan(n.y, n.x);
              float intensity = sphericalHarmonic(3.0, 0.0, theta, phi);  // Change l, m as needed

              color = vec3(intensity);
              //}

              gl_FragColor = vec4(color,1.0);
              #include <tonemapping_fragment>
              #include <colorspace_fragment>
            }
        </script>

        <script type="module" src="index.js"></script>
    </body>
</html>
